#!/bin/ksh 
################################################################################
#文件名:
#Function:
#
#History:
# 2015-07-13   jigc create
################################################################################

ECHO="echo " 
EGREP="egrep"
CMD_LIME="$0 $*"
MODE="UNKNOW-MODE"
CONFILE_NAME=""

OVERRIDE_FLAG="NO"


AWK_FORMAT_ABS_PAHT="/home/mcb3user/jigc/shell/update_tools/package-update.awk"

help(){
cat  << EOF
########################################################################
# Author      : jigc 
# Script Name : $0
# Description : 对svn改动文件进行标记
# Version     : V2.0
# Usage       : $0 -r <起始版本号>:<结束版本号|HEAD> -f <配置文件绝对路径> [-d parrten] [dirlist ... ]
#         1. parrten 需要标记为排除的文件的正则公式
#         2. dirlist 需要标记的文件列表 {warn}文件夹的顺序在打包脚本中叠加处理由"左到右叠加"
# Mark Type   : 
#    [ ]   -- 不含在 dirlist 中的文件
#    [*]   -- 包含在 dirlist 中的文件
#    [!]   -- 包含在 dirlist 中的文件，并匹配 -d 参数所指定的正则公式（过滤标志）
# Log         :
#  2014.07.01   V1.0: 实现基本功能 
#  2014.11.21   V2.0：提高容错性 
#
#
########################################################################
EOF

}

# package-utils --create-mode --conf /home/mcb3user/jigc/shell/update_tools/conf/KR-20150112-11224364.conf 
# ./package-utils --extract-mode --conf ~/shell/update_tools/update.conf  --package-name  ~/update.tgz  --backup-package-name  ~/shell/update_tools/back-xxx.tgz

# ./package-utils --extract-mode  --excute-override --conf ~/shell/update_tools/update.conf 



#获取参数##########################

#set -- `getopt cxh:bf:p:d $*` 
#eval set -- "${ARGS}"
while [ $# -gt 0 ]; 
do

	case "$1" in
	-h)
		help 
		exit 0
		;;
		
	--conf)
		
		CONFILE_NAME=$2 
		
		#获取工单号
		
		f=`basename ${CONFILE_NAME}`
		export ORDER_NAME=`echo $f | sed 's|\.conf||'`

		. $CONFILE_NAME
		shift 
		;;
	--debug)
		DEBUG="TRUE"
		break
		;;
	--create-mode)
		MODE="CREATE-MODE"
		;;
	--extract-mode)
		MODE="EXTRACT-MODE"
		 ;;
	--excute-override)
		OVERRIDE_FLAG="YES"
		;;
    --)
		
		break
		;;
    esac
shift
done

###################################


# 打包的临时目标路径在打包完成后将删除
UTILS_WORKING_DIR="$HOME/package-utils-output/${ORDER_NAME}"

# 压缩文件临时文件夹 
TAR_PACKAGE_TMP_DIR="${UTILS_WORKING_DIR}/tmp/"


# 
UPDATE_PACKAGE_NAME="${UTILS_WORKING_DIR}/${ORDER_NAME}-UPDATE.tgz"
BACKUP_PACKAGE_NAME="${UTILS_WORKING_DIR}/${ORDER_NAME}-BACKUP.tgz"


#main 入口#################################

clean_up(){
	$ECHO "rm -rf ${TAR_PACKAGE_TMP_DIR}"
}

create_init(){

$ECHO 
$ECHO 
$ECHO "################################################################################"
$ECHO "# SVN 版本号               : ${SVN_VERSION}" 
$ECHO "# SVN 基础路径             : ${SVN_BASE_FIEL_DIR}"
$ECHO "# 更新压缩包绝对值路径     : ${UPDATE_PACKAGE_NAME}" 
$ECHO "# 配置文件绝对值路径       : ${CONFILE_NAME}"
$ECHO "# 生产的目标路径           : ${DEST_DIR}"
$ECHO "# 压缩文件临时文件夹       : ${TAR_PACKAGE_TMP_DIR}"
$ECHO "# 命令行                   : ${CMD_LIME}"
$ECHO "################################################################################"
	
	clean_up
	mkdir -p ${UTILS_WORKING_DIR}
	mkdir -p ${TAR_PACKAGE_TMP_DIR}

}




my_copy(){
	source_file=$1
	dest_file=$2
	dest_dir=`dirname $dest_file` 
	[ ! -d "${dest_dir}" ] && $ECHO "mkdir -p ${dest_dir} "   | sh 
	$ECHO "cp ${source_file} ${dest_file}"   | sh
	if [ $? -eq 0 ]; then
		$ECHO  "[MESSAGE]	COPY SOURCE FILE:[ ${source_file} ] SUCCESS..."
	else
		$ECHO  "[ERROR]	COPY SOURCE FILE:[ ${source_file} ] FAILT..."
		exit 1
	fi
	
}


create_process(){
	create_init		# 初始化函数
	
	
	# 执行钩子函数
	$ECHO "\n\n[HOOK PRE-PACKAGE] BEGINE...\n" 
	(pre_package)
	$ECHO "\n[HOOK PRE-PACKAGE] END...\n\n" 
	
	$ECHO "\n[MESSAGE]	改变路径到SVN目录下: ${SVN_BASE_FIEL_DIR}\n"
	cd $SVN_BASE_FIEL_DIR 
	
	# 更新 SVN 到指定版本号
	svn up -r ${SVN_VERSION}
	if [ $? -eq 0 ]; then
		$ECHO  "[MESSAGE]	SVN UPDATE TO VERSION ${SVN_VERSION} SUCCESS..."
	else
		$ECHO  "[ERROR]		SVN UPDATE TO VERSION ${SVN_VERSION} FAILT..."
		exit 1
	fi
	
	# 解析配置文件并拷贝更新文件到指定文件夹
	
	$ECHO "\n[MESSAGE]	解析配置文件并检查cksum至后拷贝更新文件到指定文件夹: ${TAR_PACKAGE_TMP_DIR}\n"
	file_list | awk  -f ${AWK_FORMAT_ABS_PAHT} TAR_PACKAGE_TMP_DIR=${TAR_PACKAGE_TMP_DIR} DEST_DIR=${DEST_DIR} | while read line ; do
		
		$ECHO  $line | $EGREP -q "^CP"
		if [ $? -eq 0 ]; then
			$ECHO $line | read xxx src_file dest_file
			if [  -f $src_file -a ! -z $dest_file ];then
				my_copy $src_file $dest_file
			fi
		fi
		
		$ECHO  $line | $EGREP -q "^(ERROR|WARMING|DEBUG)"
		if [ $? -eq 0 ]; then
			$ECHO "[MESSAGE] $line"
		fi
	done  
	
	
	
	# 切换工作目录到生成文件的根目录
	
	$ECHO "\n[MESSAGE]	改变路径到压缩文件临时文件夹下: ${TAR_PACKAGE_TMP_DIR} ..."
	cd "${TAR_PACKAGE_TMP_DIR}"
	
	$ECHO  "[MESSAGE]	开始打包所有需要更新的文件到:[ ${UPDATE_PACKAGE_NAME} ] ...\n"
	tar -cvf "${UPDATE_PACKAGE_NAME}" *
	
	if [ $? -eq 0 ]; then
		_file_cnt=`tar -tf "${UPDATE_PACKAGE_NAME}" | sed -e '/\/$/d' | wc -l`
		$ECHO  "\n[MESSAGE]	PACKAGE FILE:[ ${UPDATE_PACKAGE_NAME}(total:$_file_cnt) ] SUCCESS..."
	else
		$ECHO  "\n[ERROR]	PACKAGE FILE:[ ${UPDATE_PACKAGE_NAME} ] FAILT..."
		exit 1
	fi
	
	
	
	# 执行钩子函数
	$ECHO "\n\n[HOOK AFTER-PACKAGE] BEGINE...\n" 
	(after_package)
	$ECHO "\n[HOOK AFTER-PACKAGE] END...\n\n" 
	

}

extract_init(){

$ECHO 
$ECHO 
$ECHO "################################################################################"
$ECHO "# 新压缩包绝对值路径       : ${PACKAGE_NAME}" 
$ECHO "# 备份压缩包绝对路径       : ${BACKUP_PACKAGE_NAME}" 
$ECHO "# 配置文件绝对值路径       : ${CONFILE_NAME}"
$ECHO "# 生产的目标路径           : ${DEST_DIR}"
$ECHO "# 压缩文件临时文件夹       : ${TAR_PACKAGE_TMP_DIR}"
$ECHO "# 执行备份                 : ${EXCUTE_FLAG}"
$ECHO "# 命令行                   : ${CMD_LIME}"
$ECHO "################################################################################"

	clean_up
	mkdir -p ${TAR_PACKAGE_TMP_DIR}
	if [ ! -f ${UPDATE_PACKAGE_NAME} ]; then 
		$ECHO  "[ERROR]	系统找不到指定单号的更新包:[ ${UPDATE_PACKAGE_NAME} ] ..."
		exit 1
	fi	

}


extract_process(){

	extract_init
	
	# 执行钩子函数
	$ECHO "\n\n[HOOK PRE-PACKAGE] BEGINE...\n" 
	(pre_backup)
	$ECHO "\n[HOOK PRE-PACKAGE] END...\n\n" 
	

	
	_update_cnt=0
	_add_cnt=0
	
	
	tar -tf ${UPDATE_PACKAGE_NAME} | sed -e '/\/$/d' | while read file; do
		if [ -f $file ]; then
			let "_update_cnt += 1"
			$ECHO  "[MESSAGE]	FILE:[ /${file} ] WILL BE UPDATE ..."
			my_copy "/$file"  "${TAR_PACKAGE_TMP_DIR}/$file"
		else
			let "_add_cnt += 1"
			$ECHO  "[WARNMING]	FILE:[ /${file} ] WILL BE ADD..."
		fi
	done
	let "_total = _update_cnt + _add_cnt"
	
	# 打印总结信息
	$ECHO  "\n[WARMING]	***  Total(${_total}), Update(${_update_cnt}),  Add(${_add_cnt}) ***\n"
	
	


	if [ ${_update_cnt} -gt 0 ]; then
	
		# 备份原文件 
		$ECHO "[MESSAGE]	改变路径到压缩文件临时文件夹下: ${TAR_PACKAGE_TMP_DIR}\n"
		cd ${TAR_PACKAGE_TMP_DIR} 
		
		$ECHO  "[MESSAGE]	开始备份所有需要更新的文件到:[ ${BACKUP_PACKAGE_NAME} ] ...\n"
	
		tar -cvf ${BACKUP_PACKAGE_NAME} *
		
		if [ $? -eq 0 ]; then
			_file_cnt=`tar -tf ${BACKUP_PACKAGE_NAME} | sed -e '/\/$/d' | wc -l`
			$ECHO  "\n[MESSAGE]	PACKAGE FILE:[ ${BACKUP_PACKAGE_NAME}(total:$_file_cnt) ] SUCCESS..."
		else
			$ECHO  "\n[ERROR]	PACKAGE FILE:[ ${BACKUP_PACKAGE_NAME} ] FAILT..."
			exit 1
		fi
	else		#  ${_update_cnt} = 0 为本次更新都是新增文件并未修改文件，所以无需备份
		$ECHO "[MESSAGE]	本次更新都是新增文件并未修改文件，所以无需备份 ...\n"
	fi 
	
	
	if [ "${OVERRIDE_FLAG}" = "YES" ]; then
		# 备份原文件 
		$ECHO "[MESSAGE]	更新文件: ${TAR_PACKAGE_TMP_DIR}\n\n"
	fi
	
	
	# 执行钩子函数
	$ECHO "\n\n[HOOK PRE-PACKAGE] BEGINE...\n" 
	(after_backup)
	$ECHO "\n[HOOK PRE-PACKAGE] END...\n\n" 
	
}


case "${MODE}" in
	
	"CREATE-MODE")
		create_process
		break
		;;
	"EXTRACT-MODE")
		extract_process
		break
		;;
	--|*)
		help
		break
		;;
esac
